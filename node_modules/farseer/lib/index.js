'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _extend = require('extend');

var _extend2 = _interopRequireDefault(_extend);

var _parserState = require('./parser-state');

var _parserState2 = _interopRequireDefault(_parserState);

var _findPlayerName = require('./find-player-name');

var _findPlayerName2 = _interopRequireDefault(_findPlayerName);

var _newPlayerIds = require('./new-player-ids');

var _newPlayerIds2 = _interopRequireDefault(_newPlayerIds);

var _handleZoneChanges = require('./handle-zone-changes');

var _handleZoneChanges2 = _interopRequireDefault(_handleZoneChanges);

var _handleGameOver = require('./handle-game-over');

var _handleGameOver2 = _interopRequireDefault(_handleGameOver);

var _setUpDebugger = require('./set-up-debugger');

var _setUpDebugger2 = _interopRequireDefault(_setUpDebugger);

var _defaultOptions = require('./default-options');

var _defaultOptions2 = _interopRequireDefault(_defaultOptions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var log = (0, _setUpDebugger2.default)();

// The watcher is an event emitter so we can emit events based on what we parse in the log.

var _class = function (_EventEmitter) {
  _inherits(_class, _EventEmitter);

  function _class(options) {
    _classCallCheck(this, _class);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(_class).call(this));

    _this.options = (0, _extend2.default)({}, (0, _defaultOptions2.default)(log), options);

    log.main('config file path: %s', _this.options.configFile);
    log.main('log file path: %s', _this.options.logFile);

    // Copy local config file to the correct location.
    // We're just gonna do this every time.
    var localConfigFile = _path2.default.join(__dirname, './log.config');
    _fs2.default.createReadStream(localConfigFile).pipe(_fs2.default.createWriteStream(_this.options.configFile));
    log.main('Copied log.config file to force Hearthstone to write to its log file.');
    return _this;
  }

  _createClass(_class, [{
    key: 'start',
    value: function start() {
      var self = this;

      var parserState = new _parserState2.default();

      log.main('Log watcher started.');
      // Begin watching the Hearthstone log file.
      var fileSize = _fs2.default.statSync(self.options.logFile).size;
      _fs2.default.watchFile(self.options.logFile, function (current, previous) {
        if (current.mtime <= previous.mtime) {
          return;
        }

        // We're only going to read the portion of the file that we have not read so far.
        var newFileSize = _fs2.default.statSync(self.options.logFile).size;
        var sizeDiff = newFileSize - fileSize;
        if (sizeDiff < 0) {
          fileSize = 0;
          sizeDiff = newFileSize;
        }
        var buffer = new Buffer(sizeDiff);
        var fileDescriptor = _fs2.default.openSync(self.options.logFile, 'r');
        _fs2.default.readSync(fileDescriptor, buffer, 0, sizeDiff, fileSize);
        _fs2.default.closeSync(fileDescriptor);
        fileSize = newFileSize;

        self.parseBuffer(buffer, parserState);
      });

      self.stop = function () {
        _fs2.default.unwatchFile(self.options.logFile);
        delete self.stop;
      };
    }
  }, {
    key: 'stop',
    value: function stop() {}
  }, {
    key: 'executor',
    value: function executor(line, state) {
      var self = this;

      state = (0, _handleZoneChanges2.default)(line, state, self.emit.bind(self), log);
      state.players = (0, _newPlayerIds2.default)(line, state.players);
      state.players = (0, _findPlayerName2.default)(line, state.players);
      state = (0, _handleGameOver2.default)(line, state, self.emit.bind(self), log);

      return state;
    }
  }, {
    key: 'parseBuffer',
    value: function parseBuffer(buffer, parserState) {
      var self = this;

      if (!parserState) {
        parserState = new _parserState2.default();
      }

      // Iterate over each line in the buffer.
      buffer.toString().split(this.options.endOfLineChar).forEach(function (line) {
        parserState = self.executor(line, parserState);
      });
    }
  }]);

  return _class;
}(_events.EventEmitter);

exports.default = _class;